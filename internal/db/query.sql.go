// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package db

import (
	"context"
)

const createCustomer = `-- name: CreateCustomer :one

INSERT INTO customers (name, email) VALUES ($1, $2) RETURNING id, name, email
`

type CreateCustomerParams struct {
	Name  string
	Email string
}

// --- CUSTOMERS -----
func (q *Queries) CreateCustomer(ctx context.Context, arg CreateCustomerParams) (Customer, error) {
	row := q.db.QueryRowContext(ctx, createCustomer, arg.Name, arg.Email)
	var i Customer
	err := row.Scan(&i.ID, &i.Name, &i.Email)
	return i, err
}

const createOrder = `-- name: CreateOrder :one


INSERT INTO orders (customer_id, product_id, units_amount, unit_price) 
VALUES ($1, $2, $3, $4) RETURNING id, customer_id, product_id, units_amount, unit_price, created_at
`

type CreateOrderParams struct {
	CustomerID  int32
	ProductID   int32
	UnitsAmount int32
	UnitPrice   int32
}

// --- ORDERS -----
func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRowContext(ctx, createOrder,
		arg.CustomerID,
		arg.ProductID,
		arg.UnitsAmount,
		arg.UnitPrice,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.ProductID,
		&i.UnitsAmount,
		&i.UnitPrice,
		&i.CreatedAt,
	)
	return i, err
}

const createProduct = `-- name: CreateProduct :one


INSERT INTO products (name, price, stock) VALUES ($1, $2, $3) RETURNING id, name, price, stock
`

type CreateProductParams struct {
	Name  string
	Price int32
	Stock int32
}

// --- PRODUCTS -----
func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, createProduct, arg.Name, arg.Price, arg.Stock)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Price,
		&i.Stock,
	)
	return i, err
}

const customerAlreadyExistsByEmail = `-- name: CustomerAlreadyExistsByEmail :one
SELECT c.id FROM customers c WHERE c.email = $1 LIMIT 1
`

func (q *Queries) CustomerAlreadyExistsByEmail(ctx context.Context, email string) (int32, error) {
	row := q.db.QueryRowContext(ctx, customerAlreadyExistsByEmail, email)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getCustomerById = `-- name: GetCustomerById :one
SELECT id, name, email FROM customers WHERE id = $1
`

func (q *Queries) GetCustomerById(ctx context.Context, id int32) (Customer, error) {
	row := q.db.QueryRowContext(ctx, getCustomerById, id)
	var i Customer
	err := row.Scan(&i.ID, &i.Name, &i.Email)
	return i, err
}

const getOrderById = `-- name: GetOrderById :one
SELECT id, customer_id, product_id, units_amount, unit_price, created_at FROM orders WHERE id = $1 LIMIT 1
`

func (q *Queries) GetOrderById(ctx context.Context, id int32) (Order, error) {
	row := q.db.QueryRowContext(ctx, getOrderById, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.ProductID,
		&i.UnitsAmount,
		&i.UnitPrice,
		&i.CreatedAt,
	)
	return i, err
}

const getOrdersByCustomerId = `-- name: GetOrdersByCustomerId :many
SELECT id, customer_id, product_id, units_amount, unit_price, created_at FROM orders WHERE customer_id = $1 LIMIT $2 OFFSET $3
`

type GetOrdersByCustomerIdParams struct {
	CustomerID int32
	Limit      int32
	Offset     int32
}

func (q *Queries) GetOrdersByCustomerId(ctx context.Context, arg GetOrdersByCustomerIdParams) ([]Order, error) {
	rows, err := q.db.QueryContext(ctx, getOrdersByCustomerId, arg.CustomerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ProductID,
			&i.UnitsAmount,
			&i.UnitPrice,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersByProductId = `-- name: GetOrdersByProductId :many
SELECT id, customer_id, product_id, units_amount, unit_price, created_at FROM orders WHERE product_id = $1 LIMIT $2 OFFSET $3
`

type GetOrdersByProductIdParams struct {
	ProductID int32
	Limit     int32
	Offset    int32
}

func (q *Queries) GetOrdersByProductId(ctx context.Context, arg GetOrdersByProductIdParams) ([]Order, error) {
	rows, err := q.db.QueryContext(ctx, getOrdersByProductId, arg.ProductID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ProductID,
			&i.UnitsAmount,
			&i.UnitPrice,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductById = `-- name: GetProductById :one
SELECT id, name, price, stock FROM products WHERE id = $1 LIMIT 1
`

func (q *Queries) GetProductById(ctx context.Context, id int32) (Product, error) {
	row := q.db.QueryRowContext(ctx, getProductById, id)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Price,
		&i.Stock,
	)
	return i, err
}

const getProducts = `-- name: GetProducts :many
SELECT id, name, price, stock FROM products p
WHERE
  ($3::TEXT IS NULL OR p."name" ILIKE '%' || $3 || '%') AND -- filter by name
  ($4::INT IS NULL OR p.price >= $4) AND -- filter by min price
  ($5::INT IS NULL OR p.price <= $5) AND -- filter by max price
  ($6::INT IS NULL OR p.stock >= $6) AND -- filter by min stock
  ($7::INT IS NULL OR p.stock <= $7) -- filter by max stock
LIMIT $1 OFFSET $2
`

type GetProductsParams struct {
	Limit   int32
	Offset  int32
	Column3 string
	Column4 int32
	Column5 int32
	Column6 int32
	Column7 int32
}

func (q *Queries) GetProducts(ctx context.Context, arg GetProductsParams) ([]Product, error) {
	rows, err := q.db.QueryContext(ctx, getProducts,
		arg.Limit,
		arg.Offset,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Price,
			&i.Stock,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementProductStockById = `-- name: IncrementProductStockById :exec
UPDATE products SET stock = stock + $2 WHERE id = $1
`

type IncrementProductStockByIdParams struct {
	ID    int32
	Stock int32
}

func (q *Queries) IncrementProductStockById(ctx context.Context, arg IncrementProductStockByIdParams) error {
	_, err := q.db.ExecContext(ctx, incrementProductStockById, arg.ID, arg.Stock)
	return err
}

const productAlreadyExistsByName = `-- name: ProductAlreadyExistsByName :one
SELECT p.id FROM products p WHERE p.name = $1 LIMIT 1
`

func (q *Queries) ProductAlreadyExistsByName(ctx context.Context, name string) (int32, error) {
	row := q.db.QueryRowContext(ctx, productAlreadyExistsByName, name)
	var id int32
	err := row.Scan(&id)
	return id, err
}
